= Темный угол Selenide
Sergey Pirogov
2016-12-17
:jbake-type: post
:jbake-tags: Java, Тест фреймворк
:jbake-summary: Скромная заметка о станностях Selenide

Привет! Решил написать заметку об одной странности Selenide, на которую натолкнулся буквально пару дней назад.

Disclaimer: все написанное ниже является моим видением и призвано помочь людям которые могут столкуться с такой же проблемой.

Проводя лекцию для сотрудников своей компании и пытаясь показать разницу между тестами на "ванильном" Selenium и Selenide,
я поймал очень неприятную ошибку, починить которую мне помогли только в Slack чатике тестировщиков.

Я рассказывал о паттерне PageObject и его реализациях с использованием все того же Selenide.

Буквально пару недель назад я уже писал подобную заметку о http://automation-remarks.com/2016/pages-objects-history/index.html[PageObject].

Итак, мы можем описывать наши страницы в таком виде:

[source, java]
----
public class MainPage {

    public void enter_keywords(String keyword) {
        $(name("search")).type(keyword);
    }

    public void lookup_terms() {
        $(".lookupButton").click();
    }
}
----

Все будет работать отлично, но не всем нравится такой формат. Ок, мы можем написать немного по-другому.

[source, java]
----
public class MainPage {

    private SelenideElement searchInput =  $("#search"));
    private SelenideElement lookupButton = $(".lookupButton");

    public void enterKeywords(String keyword) {
        search.val(keyword);
        return this;
    }

    public void lookupTerms() {
        lookupButton.click();
    }
}
----

Из-за того что метод `$()` возвращает lazy proxy, мы может писать такой код и он будет отлично работать. Ну по крайней мере я так думал =)

Давайте напишем тест:

[source, java]
----
class Test{

    @Test
    void testLookup(){
        Selenide.open("http://site.com",MainPage.class)
                .enterKeywords("hello")
                .lookupTerms()
        // assertion here
    }
}
----

Ну вроде как все лаконично и красиво. Запускаем тест и получаем такую ошибку:

[source, java]
----
INFO: Close webdriver: 1 -> FirefoxDriver: firefox on MAC (f966a581-ec80-784d-b57f-ac10a336544f)

Element not found {by id or name "searchInput"}
Expected: exist

Screenshot: file:/Users/sepi/Github/test/build/reports/tests/1481817473566.0.png
Timeout: 4 s.
----

Опа! Обратите внимание, тест падает из-за того что не может найти элемент с именем `searchInput`. Но у меня нету такого локатора, у меня есть поле класса с именем `searchInput`.

В результате выяснения причин такого поведения выяснилось, что при написании такого кода (см. ниже), нельзя использовать `PageFactory` от `Selenide` !!!

[source, java]
----
public class MainPage {

    public SelenideElement searchInput = $("#twotabsearchtextbox");
}
----

Тобишь нельзя этот класс передавать в методы **Selenide.open()** и **Selenide.page()**.

**Что же делать в таком случае?**

Нужно инизиализировать страницы как простые обекты, тобишь через **new MainPage()**, тогда все будет работать нормально.

**P/S** Имхо немного неприятное поведение, которое сначала приводит к мысли о багах в библиотеке, но на самом деле методу **open()** и **page()** были задуманы для работы и инициализации элементов PageObject написанных с исползованием аннотации **@FindBy**:

[source, java]
----
public class MainPage {

    @FindBy(css="#twotabsearchtextbox")
    public SelenideElement searchInput;
}
----

Я не могу сказать будет такое поведение исправлено или нет, возможно, нужно сделать `pull request` который будет писать внятное сообщение об ошибке по типу `"You are using page factory to initialize element without @FindBy annotation"`.

Спасибо и до новых заметок ;)
