<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JBake</title>
    <link>localhost</link>
    <atom:link href="localhost/feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>Sun, 16 Oct 2016 10:11:36 +0000</pubDate>
    <lastBuildDate>Sun, 16 Oct 2016 10:11:36 +0000</lastBuildDate>

    <item>
      <title>Будьте осторожны с TestNG лисенерами</title>
      <link>localhost/budtie-ostorozhny-s-testng-lisienierami/index.html</link>
      <pubDate>Sat, 8 Oct 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">budtie-ostorozhny-s-testng-lisienierami/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Решил написать такую вот, на мой взгляд, интересную и, наверное, для многих познавательную заметку. Сегодня поговорим о скрытых угрозах, которые несут в себе TestNG лисенеры.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;http://learn-automation.com/wp-content/uploads/2015/03/testng.jpg&quot; alt=&quot;testng&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Среди автоматизаторов, использующих Java, издавна бушует холивар, что же лучше, TestNg или JUnit. Увы, но дальше банальных переписок в Slack чате или разговоров в холле конференций дело не заходит.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Проведя небольшой экспериментальный опрос на прошедшем &lt;a href=&quot;http://automation-remarks.com/qafest-2016-rietrospiektiva/&quot;&gt;QAFest 2016&lt;/a&gt;, я был немного удивлен, что подавляющее большинство на проектах использует именно TestNG. Многим очень нравится TestNG, некоторые считают его намного более удобным, чем, скажем, тот же JUnit. Осмелюсь предположить, что большинство просто никогда не пробовало использовать JUnit чисто из исторических соображений. Пришел на проект, а там уже был TestNg, освоил его - и теперь на любом другом проекте используем то, что нам так привычно.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Мой &lt;a href=&quot;http://automation-remarks.com/java-video-recorder-1-0-8/&quot;&gt;VideoRecoder&lt;/a&gt; имеет интеграцию и с TestNG. Я реализовал такую интеграцию с помощью лисенеров, так как это самый простой и гибкий способ. НО, как оказалось, эти лисенеры влекут за собой кучу подводных камней, о которых многие, скорее всего, даже не знали.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Я опишу всего лишь два случая, которые лично меня очень сильно удивили и имели серьезное влияние на работу Java VideoRecorder.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Факт 1: Аннотация @Listener применяет лисенер ко всем классам&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Вот такая вот подлость номер один. Скажем, вы написали класс и захотели применить к нему какой-то свой лисенер:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Listeners({VideoListener.class})
class MyAwesomeTests{

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ну, вроде как отлично, запускаем - все работает, радуемся, пишем в резюме, что мы умеем делать такую классную штуку.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;НО радуемся недолго. Стоит нам написать еще пару-тройку классов с тестами, как мы заметим, что наш лисенер срабатывает и для них, хотя мы их никакими аннотациями не маркали. Вот это подарок!!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Вроде бы, ничего страшного, ну, применяется - и что?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;В случае с рекордером это потенциально могло привести к плохим последствиям. Скажем, у вас есть Test Suite, в котором есть 200-300 тестов. Вы подключаете запись видео и настраиваете его писать все тесты, независимо от того, отмечены они аннотацией &lt;strong&gt;@Video&lt;/strong&gt; или нет.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Listeners({VideoListener.class})
public class TestNgVideoExampleTest {

    @BeforeClass
    public void setUp() {
        VideoRecorder.conf().
                .withRecordMode(RecordingMode.All)
                .withVideoSaveMode(VideoSaveMode.All)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Или так:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;./gradlew test -Dvideo.mode=ALL -Dvideo.save.mode=ALL&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Запускаете свои тесты и получаете 200-300 видеороликов. Хотя вы рассчитывали записать только один класс, в котором значительно меньшее количество тестов.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Естественно, когда я нашел такой баг в своей библиотеке, то начал думать, как это исправить. Решение оказалось таким: нам нужно написать свой метод проверки аннотации для класса, который в данный момент &quot;прослушивается&quot;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public boolean shouldIntercept(ITestResult result) {
        List&amp;lt;String&amp;gt; listeners = result.getTestContext().getCurrentXmlTest().getSuite().getListeners();
        return listeners.contains(this.getClass().getName()) || shouldIntercept(result.getTestClass().getRealClass(), this.getClass());
    }

public boolean shouldIntercept(Class testClass, Class annotation) {
        Listeners listenersAnnotation = getListenersAnnotation(testClass);
        return listenersAnnotation != null &amp;amp;&amp;amp; asList(listenersAnnotation.value()).contains(annotation);
    }

    private Listeners getListenersAnnotation(Class testClass) {
        Annotation annotation = testClass.getAnnotation(Listeners.class);
        return annotation != null ? (Listeners) annotation :
                testClass.getSuperclass() != null ? getListenersAnnotation(testClass.getSuperclass()) : null;
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ну, и затем нужно просто использовать этот метод в методах лисенера:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class VideoListener extends TestNgListener {

    @Override
    public void onTestStart(ITestResult result) {
        if (shouldIntercept(result)) {
            // code here
        }
    }

    .... another methods&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Теперь ваш лисенер будет срабатывать только для тех классов, у которых аннотация &lt;strong&gt;@Listener&lt;/strong&gt; содержит &lt;strong&gt;VideoListener.class&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Стоит отметить, что в случае подключения лисенера через &lt;strong&gt;testng.xml&lt;/strong&gt;, он таки будет применен ко всему сьюту:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;suite name=&quot;Suite&quot; parallel=&quot;false&quot;&amp;gt;
    &amp;lt;listeners&amp;gt;
        &amp;lt;listener class-name=&quot;com.automation.remarks.testng.VideoListener&quot; /&amp;gt;
    &amp;lt;/listeners&amp;gt;

    &amp;lt;test name=&quot;Test&quot;&amp;gt;
        &amp;lt;classes&amp;gt;
            &amp;lt;class name=&quot;com.testng.TestClass&quot; /&amp;gt;
        &amp;lt;/classes&amp;gt;
    &amp;lt;/test&amp;gt;
&amp;lt;/suite&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Это выглядит логично, так как блок &lt;strong&gt;&amp;lt;listeners&amp;gt;&lt;/strong&gt; находится внутри тега &lt;strong&gt;&amp;lt;suite&amp;gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Факт 2: Порядок выполнения лисенеров не гарантируется&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Второй интересный момент, который принес мне много головной боли.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Скажем, вам нужно подключить два лисенера. В моем случае - один, который пишет видео, а второй, который аттачит это самое видео к &amp;lt;mark&amp;gt;Allure&amp;lt;/mark&amp;gt; отчету.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ок, берем и пишем:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Listeners({VideoListener.class, AllureListener.class})
class TestClass{
 // tests here
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Кажется, все отлично: один пишет видео, другой по окончании теста аттачит его в отчет. Но выяснилось, что в некоторые моменты происходила непонятная фигня: видео записывалось, но не отображалось в отчете.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Оказалось, что это случалось потому, что методы из &lt;strong&gt;AllureListener&lt;/strong&gt; вызывались первее. Ну вообще подарок!!!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Начав копаться внутри TestNG, я определил, что все лисенеры складываются в Set и потом вызываются. Естественно, что о какой-то очередности речи и быть не может.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Как же все-таки гарантировать очередность вызова? Ответ: иметь один лисенер!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;class AllureVideoListener extends VideoListener{

    @Override
    public void onTestFailure(ITestResult result) {
        super.onTestFailure(result);
        attachment(VideoRecorder.getLastRecording())
    }

    @Attachment(value = &quot;video&quot;, type = &quot;video/mp4&quot;)
    private byte[] attachment(File video) {
        try {
            return Files.readAllBytes(Paths.get(video.getAbsolutePath()));
        } catch (IOException e) {
            log.warning(&quot;Allure listener exception&quot; + e);
            return new byte[0];
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Вот так. Да, я мог вызывать метод attachment не в лисенере, а, скажем, в after method и тогда бы не натолкнулся на это. Но, если вдруг окажется так, что порядок выполнения лисенеров для вас будет важен, я вас предупредил =)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Такая вот история моей битвы с &lt;strong&gt;TestNG&lt;/strong&gt; и его лисенерами. Естественно, что этот кейс может быть слишком узок и вы в своих проектах никогда не натолкнетесь на это. Но это один из тех моментов, когда можно научиться на ошибках других, и весомый пункт в пользу несовершенности TestNg.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Субъективное мнение по поводу &lt;strong&gt;TestNG&lt;/strong&gt; vs &lt;strong&gt;JUnit&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Лично я очень жду &lt;strong&gt;JUnit 5&lt;/strong&gt;, который уже попробовал, но в реальный проект его брать еще рано. Имхо он заткнет TestNG за пояс, нужно лишь немного подождать.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Успехов и до новых заметок..&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>QAFest 2016: ретроспектива</title>
      <link>localhost/qafest-2016-rietrospiektiva/index.html</link>
      <pubDate>Sun, 2 Oct 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">qafest-2016-rietrospiektiva/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Как и в прошлом &lt;a href=&quot;http://automation-remarks/qafest-retrospective/&quot;&gt;году&lt;/a&gt;, мне посчастливилось посетить это мероприятие в качестве докладчика.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/qa_fest_2016.jpg&quot; alt=&quot;qa fest 2016&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;В этом году организаторы решили немного изменить формат и разбить программу на два дня. Первый - &lt;strong&gt;Junior Day&lt;/strong&gt; - был полностью посвящен молодому поколению, ну и, естественно, Main Day - для более мастеровитой аудитории.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Я, как любитель поговорить на публике, выступал и в первый, и во второй день.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Хочу отметить, что идея сделать два разноплановых дня лично мне очень понравилась, так как можно подготовить доклады разных уровней. К тому же, выступление в первый день дает возможность немного привыкнуть к сцене перед основным днем.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Мне выпала честь открывать &lt;strong&gt;Junior Day&lt;/strong&gt; и выступить первым. Не буду спойлить, дождетесь видео и посмотрите сами, о чем я рассказывал. Хочу лишь отметить, что выступать первым немного волнительно, поэтому первых минут 10 во время выступления у меня дрожал голос =) Но потом все наладилось и я откатал доклад на вполне достойном уровне.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Из всех выступлений первого дня мне больше всего понравился доклад &lt;strong&gt;Per Thorsheim Website security 101&lt;/strong&gt;. Я не очень глубоко подкован во всех этих сесюрных штучках, поэтому даже доклад на уровне джуниоров для меня был интересен и полезен. Более того, Per уже второй год подряд приезжает с очень интересными докладами, которые позволяют расширить кругозор и задуматься над нашим поведением в глобальной сети.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Все остальные доклады были уж слишком джуниорскими, поэтому я в основном находился в холле и общался с организаторами либо же другими участниками.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Второй - &lt;strong&gt;Main Day&lt;/strong&gt; - был намного интереснее и ярче. Собрались все самые маститые докладчики со своими лучшими докладами.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Я думаю все &lt;strong&gt;700(!)&lt;/strong&gt; участников с нетерпением ждали открытия основного дня конференции. Как обычно все начиналось с утреннего чаепития и общения. В 10:00 я пошел на первый доклад о Groovy. Думаю, постоянным читателям блога не нужно объяснять, почему я выбрал именно его =)
&lt;a href=&quot;http://automation-remarks.com/seleniumcamp-2016-vidieo/&quot;&gt;Groovy рулит&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Самым крутым докладом дня я считаю выступление Анастасии Асеевой &lt;strong&gt;&quot;Роль тестирования в Devops&quot;&lt;/strong&gt;. Когда появится видео, вы сможете сами оценить полезность и крутость этого доклада.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ближе к обеду пришел черед моего выступления. Для синьоров я подготовил доклад о Докерах. В целом я рассказывал о библиотеках &lt;strong&gt;testcontainers&lt;/strong&gt; для Java и Python.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;После этого все послушали эфир &lt;strong&gt;Radio QA&lt;/strong&gt; и начали медленно готовиться к афтепати.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Закрытие конференции было достаточно традиционным - с розыгрышами призов и подарков. Естественно, мы не стали расходиться по домам, а еще послушали стендап-комиков и приличное количество времени общались в узком кругу спикеров.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Конференция &lt;strong&gt;QAFest 2016&lt;/strong&gt; закончилась, а впереди целый год для поиска и подготовки новых интересных и полезных докладов для &lt;strong&gt;QAFest 2017&lt;/strong&gt; :D&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Анонс SQA Days 19</title>
      <link>localhost/anons-sqa-days-19/index.html</link>
      <pubDate>Sat, 30 Jan 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">anons-sqa-days-19/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Компания &quot;Лаборатория тестирования&quot; объявила даты проведения Software Quality Assurance Days - крупнейшей в СНГ международной конференции по вопросам качества программного обеспечения. Следующая, девятнадцатая по счету конференция пройдет 20-21 мая в Санкт-Петербурге. Культурная столица примет конференцию уже в четвертый раз.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ожидается, что SQA Days-19 посетят не менее 600 гостей из различных стран ближнего и дальнего зарубежья. Как и на предыдущих SQA Days, здесь будут обсуждаться разнообразные вопросы обеспечения качества: от глобальных тенденций в QA-индустрии до частных, но не менее важных и интересных случаев применения различных методов и инструментов на реальных проектах.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Технический трек конференции традиционно уделит много внимания автоматизированному тестированию: среди заявленных тем - актуальные &quot;фреймворки&quot;, приемы и технологии, а также их практическое использование при разработке и поставке ПО.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Не будут забыты и другие не теряющие актуальности профессиональные области: функциональное тестирование, тестирование безопасности и поиск уязвимостей, а также тестирование пользовательских интерфейсов.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Наконец, ожидаются доклады на такие востребованные темы, как управление тестированием, эффективная работа с партнерами и заказчиками, организация работы команд тестировщиков, профессиональное обучение специалистов в области Quality Assurance.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Пока расписание конференции формируется, организаторы будут рады конструктивным предложениям и, конечно же, новым докладчикам. Предложить собственный доклад на конференцию можно через форму на сайте SQA Days.&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Настраиваем Selenium Grid за 5 минут</title>
      <link>localhost/nastraivaiem-selenium-grid-za-5-minut/index.html</link>
      <pubDate>Mon, 15 Jun 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">nastraivaiem-selenium-grid-za-5-minut/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Заметка о том, как правильно настроить &lt;strong&gt;Selenium-Grid&lt;/strong&gt;. Многие делали это неоднократно, а некоторые даже не знают, что это такое. Ориентируюсь на обе части аудитории: если у вас есть опыт, заметка будет служить такой себе справкой - вдруг чего забыли; если вы не пробовали, но очень хотели - это прекрасный шанс начать.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Итак &lt;strong&gt;Selenium-Grid&lt;/strong&gt; позволяет запускать тесты на разных машинах в разных браузерах параллельно.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;http://cdn.guru99.com/images/hub_and_nodes.jpg&quot; alt=&quot;hub and nodes&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;В основном Selenium Grid используют по нескольким причинам:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Note&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Для распараллеливания запуска тестов на различных операционных системах, в различных браузерах;
Для того, чтобы уменьшить общее время прогона тестов.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Selenium Grid оперирует такими составляющими, как Hub и Node.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Что такое Hub?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Note&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Hub - центральная точка, которая принимает запросы и направляет их к Node. Такой себе командный пункт.
В гриде может быть только один Hub.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Что такое Node?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Note&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Node - Selenium инстанс, который будет запускать команды, загружаемые в Hub.
Node может быть много в гриде.
Node - может запускаться на разных операционных системах с разными браузерами.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Начало настройки:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Скачать &lt;strong&gt;Selenium Server Standalone&lt;/strong&gt; &lt;a href=&quot;http://docs.seleniumhq.org/download/&quot;&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Создайте папку &lt;strong&gt;seleniumgrid&lt;/strong&gt; и скопируйте в нее скачанный &lt;strong&gt;selenium_server_x.xx.x.jar&lt;/strong&gt; файл.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Стартуем Hub.&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Открываем окно команд и выполняем:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;java -jar selenium_server_standalone_2.46.0.jar -role hub&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Должно появиться что-то подобное этому:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;http://cdn.guru99.com/images/launch_hub.jpg&quot; alt=&quot;launch hub&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Для того, чтобы проверить, что все стартовало правильно, нужно набрать в браузере&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;http://localhost:4444/grid/console&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Стартуем Node.&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;В моем случае и &lt;strong&gt;Hub&lt;/strong&gt; и &lt;strong&gt;Node&lt;/strong&gt; расположены на одном компьютере, но это не сильно меняет ситуацию.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Открываем консоль и пишем:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Node для браузера &lt;strong&gt;FireFox&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;java -jar selenium-server-standalone-2.46.0.jar -role webdriver -hub http://localhost:4444/grid/register -port 5556 -browser browserName=firefox&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Для браузеров Chrome и Internet Explorer настройка немного отличается. Нужно дописать путь к драйверам соответствующих браузеров -Dwebdriver.ie.driver=IEDriverServer.exe и -Dwebdriver.chrome.driver=chromedriver.exe. Скачать драйверы можно на сайте selenium.org&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Полные команды выглядят так:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;&lt;strong&gt;Internet Explorer&lt;/strong&gt;&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;java -Dwebdriver.ie.driver=IEDriverServer.exe -jar selenium-server-standalone-2.46.0.jar -role webdriver -hub
http://localhost:4444/grid/register -port 5558 -browser browserName=iexplorer&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Для Internet explorer я уже описывал, как можно использовать драйвер, написанный самим Майкрософт. Смотреть &lt;a href=&quot;http://automation-remarks.com/kak-pokorit-internet-explorer/&quot;&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;&lt;strong&gt;Chrome&lt;/strong&gt;&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;java -Dwebdriver.chrome.driver=chromedriver.exe -jar selenium-server-standalone-2.46.0.jar -role webdriver -hub
http://localhost:4444/grid/register -port 5558 -browser browserName=chrome&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Для того, чтобы проверить, что все настроено корректно, нужно открыть все тот же &lt;a href=&quot;http://localhost:4444/grid/console&quot; class=&quot;bare&quot;&gt;http://localhost:4444/grid/console&lt;/a&gt; и убедиться, что там отображается один истанс IE и один Chrome.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Следует добавить, конфигурировать Hub и Node можно с помощью JSON файлов.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Пример для &lt;strong&gt;Hub&lt;/strong&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;java -jar selenium-server-standalone.jar -role hub -hubConfig hubconfig.json&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Содержимое json файла &lt;a href=&quot;https://github.com/SeleniumHQ/selenium/blob/master/java/server/src/org/openqa/grid/common/defaults/DefaultHub.json&quot;&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Пример для &lt;strong&gt;Node&lt;/strong&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;java -jar selenium-server-standalone.jar -role node -nodeConfig nodeconfig.json&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Содержимое json файла &lt;a href=&quot;https://github.com/SeleniumHQ/selenium/blob/master/java/server/src/org/openqa/grid/common/defaults/DefaultNode.json&quot;&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ну вот и все, в следующих заметках я покажу, как пользоваться настроенным гридом и запускать тесты. Если вам интересно, подписывайтесь,чтобы получать обновления первым.&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Магия Groovy и SQL</title>
      <link>localhost/maghiia-groovy-i-sql/index.html</link>
      <pubDate>Tue, 12 May 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">maghiia-groovy-i-sql/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Новая заметка, о том как можно упростить и ускорить тестирование баз данных.
Начну с описания примерной ситуации, в которой может пригодиться данный подход. Скажем, есть у вас схема базы данных и вы перед стартом приложения, хотите проверить целостность базы данных и находящихся в ней данных. Для этого можно использовать различные подходы, я покажу один из них. В показаном примере используется Groovy. Лично для меня, он привлекателен тем, что некоторые вещи можно делать проще и быстрее. К примеру я уже показывал здесь как быстро и просто прочитать данные из url.
Итак приступим к делу, в примере ниже, я покажу как соедениться с базой данных SQLite. Итак открываем Groovy Console и пишем:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;@Grapes([
 @Grab(group=&apos;org.xerial&apos;,module=&apos;sqlite-jdbc&apos;,version=&apos;3.7.2&apos;),
 @GrabConfig(systemClassLoader=true)
])

import java.sql.*
import org.sqlite.SQLite
import groovy.sql.Sql

//Class.forName(&quot;org.sqlite.JDBC&quot;)

def sql = Sql.newInstance(&quot;jdbc:sqlite:sample.db&quot;, &quot;org.sqlite.JDBC&quot;)

sql.execute(&quot;drop table if exists person&quot;)
sql.execute(&quot;create table person (id integer, name string)&quot;)

def people = sql.dataSet(&quot;person&quot;)
people.add(id:1, name:&quot;leo&quot;)
people.add(id:2,name:&apos;yui&apos;)

sql.eachRow(&quot;select * from person&quot;) {
  println(&quot;id=${it.id}, name= ${it.name}&quot;)
}

result:
id=1, name= leo
id=2, name= yui&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Вот так вот, всего пару строк, котрые позволяют создать таблицу, заполнить ее данными и извлечь их.
Пойдем еще дальше, так как груви консоль - это инструмент &quot;поиграться&quot;.
Берем более серъезные инструменты &lt;strong&gt;Groovy + Spock Framework&lt;/strong&gt;.Базы данных &lt;strong&gt;H2&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Создаем тестовый класс:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;import groovy.sql.Sql
import spock.lang.Shared
import spock.lang.Specification

class DatabaseDrivenSpec extends Specification {
    @Shared
            sql = Sql.newInstance(&quot;jdbc:h2:mem:&quot;, &quot;org.h2.Driver&quot;)

    // insert data (usually the database would already contain the data)
    def setupSpec() {
        sql.execute(&quot;&quot;&quot;
                        CREATE TABLE employees
                        ( employee_number number(10) not null,
                          employee_name varchar2(50) not null,
                          salary number(6),
                          CONSTRAINT employees_pk PRIMARY KEY (employee_number)
                        );
                    &quot;&quot;&quot;
        );

sql.execute(&quot;INSERT INTO employees (employee_number, employee_name, salary) VALUES (1001, &apos;Sally Johnson&apos;, 32000);&quot;)
    }


    def &quot;employees test&quot;() {
        expect:
        employee_number == 1001
        employee_name == &quot;Sally Johnson&quot;
        salary == 32000

        where:
        [employee_number, employee_name, salary] &amp;lt;&amp;lt; sql.rows(&quot;select * from employees&quot;)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Можно очень легко читать .sql файлы.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;String query = new File(&apos;insert.sql&apos;).text
sql.execute(query)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Вот так вот, мы очень легко и понятно можем обращаться с данными используя Groovy SQL.&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Достойная замена проперти файлам</title>
      <link>localhost/zamienitie-property-faily-na-ghruvi-skripty/index.html</link>
      <pubDate>Tue, 12 May 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">zamienitie-property-faily-na-ghruvi-skripty/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Этой заметкой я продолжу когда-то уже начатый разговор о груви. Сегодня хочу предложить подход, который я испробовал лично, а именно - заменить проперти файл в проекте на груви скрипт.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Итак у нас есть стандартный Java проект со стандартной структурой. Создадим в папке &lt;strong&gt;resources&lt;/strong&gt; файл &lt;strong&gt;config.groovy&lt;/strong&gt; со следующим содержанием:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;environments{
    local{
        mail = &quot;localhost&quot;
        servers{
            linux = &quot;0.0.0.0&quot;
            solaris = &quot;192.168.1.1&quot;
        }
    }
    prod{
        mail = &quot;prodhost&quot;
        servers = [&quot;1.1.1.1&quot;,&quot;2.2.2.2.2&quot;]
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Стандартная ситуация: у нас есть несколько инвайроментов, на которых мы можем запускать тесты. Теперь начнется магия груви. Создаем класс:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Config.groovy&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;class Config {

    final String CONFIG_FILE = &apos;src/test/resources/config.groovy&apos;
    final String ENVIRONMENTS = &apos;environments&apos;

    def read() {
        new File(CONFIG_FILE).text
    }

    def getEnv(String envName) {
        def config = new ConfigSlurper(envName)
        config.registerConditionalBlock(ENVIRONMENTS, envName)
        config.parse(read())
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Сердцем этого класса является метод &lt;strong&gt;getEnv&lt;/strong&gt;, который использует &lt;strong&gt;ConfigSlurper&lt;/strong&gt;. ConfigSlurper может парсить груфи файлы, что даст нам возможность использовать скрипты вместо стандартных Java проперти файлов. Ну и теперь нам остается попробовать класс в действии:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;class ConfigTest {
    public static void main(String[] args) {
        def local= new Config().getEnv(&apos;local&apos;)
        println &quot;Local&quot;
        println local.mail
        println local.servers.linux
        println local.servers.solaris

        def prod = new Config().getEnv(&apos;prod&apos;)
        println &quot;Production&quot;
        println prod.mail
        println prod.servers
    }
}

Console output:
Local
localhost
0.0.0.0
192.168.1.1

Production
prodhost
[1.1.1.1, 2.2.2.2.2]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Собственно, результат говорит сам за себя. Лично мое мнение: груви скрипты могут полностью заменить проперти файлы, к тому же скрипт обладает большими возможностями, чем проперти файл. А как вы считаете, применим ли такой подход на вашем проекте?&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>SQL для мануальных тестировщиков</title>
      <link>localhost/sql-dlia-manualnykh-tiestirovshchikov/index.html</link>
      <pubDate>Sun, 10 May 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">sql-dlia-manualnykh-tiestirovshchikov/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Лекция предназначенная для мануальных тестироовщиков. Речь будет идти про SQL. Полезно тем, кто хотел бы изучить основыи научиться писать запросы.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;videoblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;iframe src=&quot;https://www.youtube.com/embed/JfhtwAyQbT4?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;videoblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;iframe src=&quot;https://www.youtube.com/embed/83VuI7aTVZo?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;videoblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;iframe src=&quot;https://www.youtube.com/embed/5XjyHjzbLEo?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>4 библиотеки, о которых должен знать каждый Автоматизатор</title>
      <link>localhost/davaitie-poghovorim-pro-asserty/index.html</link>
      <pubDate>Tue, 5 May 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">davaitie-poghovorim-pro-asserty/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Самая выразительная часть хорошо написанного теста - хорошо написанный assert (acсершин, ассерт далее). Assert подтверждает поведение системы, которое вы ожидаете. Хороший assert должен с первого взгляда показывать, что делает тест. Ни в коем случае в ваших тестах не должно быть циклов, в недрах которых будет спрятан assert, и вам нужно будет потратить уйму времени, чтобы разобраться с тем, что происходит. Более того, любая не тривиальная логика в тест кейсе повышает риск того, что тест сам по себе неправильный.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;http://www.itshouldjustworktm.com/wp-content/uploads/2012/03/assert-sign-photoshopped.jpg&quot; alt=&quot;assert sign photoshopped&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;В последние годы значительно увеличилось количество подходов, инструментов и библиотек, которые позволяют просто и быстро писать легко читаемый код. Это касается как кода программы, так и кода тестов.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;В области написания тестов существует много библиотек, которые поддерживают понятные ассершины на любом языке. Вы можете спросить: &quot;А зачем оно нужно?&quot;. Легко читаемые ассершины - это самый простой путь написания утверждений в более естественной, более доступной и более экспрессивной манере.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Существует два подхода для написания ассертов. Первый - используя ключевое слово &quot;assert&quot;, второй же - используя такие слова как &lt;strong&gt;&quot;should&quot;&lt;/strong&gt; или &lt;strong&gt;&quot;expect&quot;&lt;/strong&gt;. Первый берет свое начало из более традиционного стиля написания юнит тестов и фокусируется на тестировании и верификации. Второй - более BDD - ориентирован - слова &quot;should&quot; и &quot;expect&quot; описывают поведение, которое вы ожидаете от системы. В этой заметке я предлагаю рассмотреть несколько библиотек, которые помогут в написании понятных ассертов.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Аssertions in JavaScript.&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JavaScript обладает большим количеством библиотек, которые помогают делать ассерты более выразительными. Jasmine имеет встроенную функцию &lt;code&gt;expect()&lt;/code&gt;. Такие библиотеки как &lt;strong&gt;Should.js&lt;/strong&gt; и &lt;strong&gt;Chai&lt;/strong&gt; поддерживают схожие функции.
Я покажу пару примеров из библиотеки &lt;strong&gt;Chai&lt;/strong&gt;, так как она является самой гибкой и поддерживает оба формата: как &lt;code&gt;expect()&lt;/code&gt; и &lt;code&gt;should()&lt;/code&gt;, так и старый формат - assert. &lt;strong&gt;Chai&lt;/strong&gt; фокусируется на использовании цепочек для того, чтобы сделать утверждения более читабельными и выразительными.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;var expect = require(&apos;chai&apos;).expect

var medal = &quot;Bronze&quot;;
...
expect(medal).to.equal(&apos;Bronze&apos;);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Chai поддерживает богатый набор ассертов для коллекций:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;var obtainableStatuses = [&apos;Silver&apos;,&apos;Gold&apos;,&apos;Platinum&apos;]
...
expect(obtainableStatuses).to.have.length(3).and.to.include(&apos;Gold&apos;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ну и наконец assert в стиле BDD:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;var expect = require(&apos;chai&apos;).should();

medal.should.equal(&apos;Bronze&apos;);
obtainableStatuses.should.have.length(3).and.include(&apos;Silver&apos;);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Следует отметить, что оба подхода одинаково выразительны. Таким образом выбор стиля написания зависит от персональных предпочтений. Лично мой выбор в пользу &lt;strong&gt;should&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Assertions in Java.&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Буду немного Капитаном Очевидностью и скажу, что библиотеки для написания внятных утверждений существуют и в Java. Они менее выразительны, чем их динамический эквивалент. В Java существуют стандартные утверждения, которые можно получить, используя такие всем известные библиотеки, как &lt;strong&gt;JUnit&lt;/strong&gt; и &lt;strong&gt;TestNG&lt;/strong&gt;. Но ассершины, которые они предоставляют, как по мне, бедноваты и слишком просты по сравнению с теми, о которых далее пойдет речь.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Я приведу пример нескольких библиотек, которые, по моему мнению, могут быть полезными.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;1. Hamcrest&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Пожалуй, самая известная библиотека из этой области. Основной метод, который в ней используется, называется &lt;strong&gt;assertThat()&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;

import junit.framework.TestCase;

public class BiscuitTest extends TestCase {
  public void testEquals() {
    Biscuit theBiscuit = new Biscuit(&quot;Ginger&quot;);
    Biscuit myBiscuit = new Biscuit(&quot;Ginger&quot;);
    assertThat(theBiscuit, equalTo(myBiscuit));
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Самое приятное, что она предоставляет большой выбор матчеров:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;Core
    anything - always matches, useful if you don&apos;t care what the object under test is
    describedAs - decorator to adding custom failure description
    is - decorator to improve readability - see &quot;Sugar&quot;, below
Logical
    allOf - matches if all matchers match, short circuits (like Java &amp;amp;&amp;amp;)
    anyOf - matches if any matchers match, short circuits (like Java ||)
    not - matches if the wrapped matcher doesn&apos;t match and vice versa
Object
    equalTo - test object equality using Object.equals
    hasToString - test Object.toString
    instanceOf, isCompatibleType - test type
    notNullValue, nullValue - test for null
    sameInstance - test object identity
Beans
    hasProperty - test JavaBeans properties
Collections
    array - test an array&apos;s elements against an array of matchers
    hasEntry, hasKey, hasValue - test a map contains an entry, key or value
    hasItem, hasItems - test a collection contains elements
    hasItemInArray - test an array contains an element
Number
    closeTo - test floating point values are close to a given value
    greaterThan, greaterThanOrEqualTo, lessThan, lessThanOrEqualTo - test ordering
Text
    equalToIgnoringCase - test string equality ignoring case
    equalToIgnoringWhiteSpace - test string equality ignoring differences in runs of whitespace
    containsString, endsWith, startsWith - test string matching&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Более подробно можно посмотреть на их &lt;a href=&quot;https://code.google.com/p/hamcrest/wiki/Tutorial&quot;&gt;сайте&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Лично я пользуюсь этой библиотекой.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;2. FestAssert&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Как утрверждают сами разработчики:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Note&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
FEST Assertions 2.0 is a Java library that provides a fluent interface for writing assertions. Its main goal is to improve test code readability and make maintenance of tests easier.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Парочка примеров использования:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import static org.fest.assertions.api.Assertions.*;

// common assertions
assertThat(yoda).isInstanceOf(Jedi.class);
assertThat(frodo.getName()).isEqualTo(&quot;Frodo&quot;);
assertThat(frodo).isNotEqualTo(sauron);
assertThat(frodo).isIn(fellowshipOfTheRing);
assertThat(sauron).isNotIn(fellowshipOfTheRing);

// String specific assertions
assertThat(frodo.getName()).startsWith(&quot;Fro&quot;).endsWith(&quot;do&quot;)
                           .isEqualToIgnoringCase(&quot;frodo&quot;);

// collection specific assertions
assertThat(fellowshipOfTheRing).hasSize(9)
                               .contains(frodo, sam)
                               .excludes(sauron);
// throwable specific assertions
try {
  fellowshipOfTheRing.get(9); // argggl !
} catch (Exception e) {
  assertThat(e).isInstanceOf(IndexOutOfBoundsException.class)
               .hasMessage(&quot;Index: 9, Size: 9&quot;)
               .hasNoCause();
}

// map specific assertions (One ring and elves ring bearers initialized before)
assertThat(ringBearers).hasSize(4)
                       .includes(entry(oneRing, frodo), entry(nenya, galadriel))
                       .excludes(entry(oneRing, aragorn));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Лично я на проектах активно не использовал эту библиотеку, но меня она привлекла тем, что есть готовые ассершины для &lt;strong&gt;Joda Time&lt;/strong&gt;, &lt;strong&gt;Guava&lt;/strong&gt;. Также есть возможность использования компараттора для утверждений.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;// frodo and sam are instances of Character with Hobbit race (obviously :), they are not equal ...
assertThat(frodo).isNotEqualTo(sam);
// ... but if we compare race only, they are (raceComparator implements Comparator&amp;lt;Character&amp;gt;)
assertThat(frodo).usingComparator(raceComparator).isEqualTo(sam);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Более подробно можно посмотреть и скачать &lt;a href=&quot;https://github.com/alexruiz/fest-assert-2.x&quot;&gt;здесь&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Обе эти библиотеки очень похожи, они предлагают большой набор матчеров. Например для того, чтобы проверить, что список содержит элементы. В хамкресте это делается так:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;assertThat(member.getUnachievedStatuses(), hasItems(GOLD,PLATINUM));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;В &lt;strong&gt;FestAssert&lt;/strong&gt; это будет выглядеть так:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;assertThat(member.getUnachievedStatuses()).contains(GOLD,PLATINUM);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;К сожалению, FestAssert больше не активен, поэтому взамен этой библиотеки предлагаю посмотреть на следующую в списке.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;3. AssertJ&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;AssertJ&lt;/strong&gt; - форк библиотеки Fest Assert, предоставляет большой набор утверждений, сообщений об ошибках и позволяет улучшить читабельность тестового кода.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;// unique entry point to get access to all assertThat methods and utility methods (e.g. entry)
import static org.assertj.core.api.Assertions.*;

// common assertions
assertThat(frodo.getName()).isEqualTo(&quot;Frodo&quot;);
assertThat(frodo).isNotEqualTo(sauron)
                 .isIn(fellowshipOfTheRing);

// String specific assertions
assertThat(frodo.getName()).startsWith(&quot;Fro&quot;)
                           .endsWith(&quot;do&quot;)
                           .isEqualToIgnoringCase(&quot;frodo&quot;);

// collection specific assertions
assertThat(fellowshipOfTheRing).hasSize(9)
                               .contains(frodo, sam)
                               .doesNotContain(sauron);

// using extracting magical feature to check fellowshipOfTheRing characters name :)
assertThat(fellowshipOfTheRing).extracting(&quot;name&quot;).contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;, &quot;Legolas&quot;)
                                                  .doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);

// map specific assertions, ringBearers initialized with the elves rings and the one ring bearers.
assertThat(ringBearers).hasSize(4)
                       .contains(entry(oneRing, frodo), entry(nenya, galadriel))
                       .doesNotContainEntry(oneRing, aragorn);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Больше примеров и документации можно найти на их &lt;a href=&quot;http://joel-costigliola.github.io/assertj/&quot;&gt;сайте&lt;/a&gt;. Лично я в своем следующем проекте обязательно буду использовать &lt;strong&gt;AssertJ&lt;/strong&gt;, так как он, по моему личному мнению, лучше и проще, чем &lt;strong&gt;Hamcrest&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;4.Google Truth&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Еще одна библиотечка от одноименной компании с очень приятным именем.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;Set&amp;lt;Foo&amp;gt; foo = ...;
assertTrue(foo.isEmpty()); // or, shudder, foo.size() == 0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Дает непонятное и нечитабельное исключение:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;java.lang.AssertionError
    at org.junit.Assert.fail(Assert.java:92)
    at org.junit.Assert.assertTrue(Assert.java:43)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;С применением Truth читабельность и понятность гораздо выше:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;Set&amp;lt;Foo&amp;gt; foo = ...;
assertThat(foo).isEmpty()


org.truth0.FailureStrategy$ThrowableAssertionError: Not true that  is empty
    at org.truth0.FailureStrategy.fail(FailureStrategy.java:33)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Хотите узнать больше и попробовать, смотрите здесь &lt;a href=&quot;http://google.github.io/truth/&quot;&gt;cайт&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ну вот собственно и все.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Небольшой итог об этих монстрах:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Hamcrest&lt;/strong&gt; и &lt;strong&gt;FestAssert&lt;/strong&gt; играют подобные роли в Java-based BDD. Hamcrest более гибкий и легко расширяемый, но FestAssert обладает более простым синтаксисом и более прост в использовании. &lt;strong&gt;AssertJ&lt;/strong&gt; - улучшенная версия &lt;strong&gt;FestAssert&lt;/strong&gt;, которая обладает уймой полезных фишек.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;В целом все библиотеки предназначены для того, чтобы сделать юнит тесты проще и понятнее. Хороших вам assertов =)&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>CI &amp; Build tools for newbies</title>
      <link>localhost/ci-build-tools-for-newbies/index.html</link>
      <pubDate>Fri, 1 May 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">ci-build-tools-for-newbies/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Привет! Новый пост - лекция про билд тулы и континиус интегрейшин.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;videoblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;iframe src=&quot;https://www.youtube.com/embed/XpVNDRRjtsw?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;videoblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;iframe src=&quot;https://www.youtube.com/embed/dacqCkdFbP8?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;videoblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;iframe src=&quot;https://www.youtube.com/embed/CVItdJV_cqM?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Свое АОP в JDK</title>
      <link>localhost/svoie-aop/index.html</link>
      <pubDate>Sun, 29 Mar 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">svoie-aop/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Заметка о том, как можно реализовать &lt;strong&gt;AOP&lt;/strong&gt; без &lt;strong&gt;Spring&lt;/strong&gt; и &lt;strong&gt;AspectJ&lt;/strong&gt;. Для тех, кто не особо в курсе, что такое AOP смотреть суда. Итак, приступим. Создадим нашу мини программу:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public interface Calculator {
    public int calculate( int a , int b);
}

public class CalculatorImpl implements Calculator {
    @Override
    public int calculate(int a, int b) {
        System.out.println(&quot;**********Actual Method Execution**********&quot;);
        return a/b;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Класс &lt;strong&gt;Calculator&lt;/strong&gt; будет имеенно тем классом, который мы будем проксировать. В java есть такой интересный интерфейс &lt;strong&gt;InvocationHandler&lt;/strong&gt;, его мы и будем использовать для нашей реализации &lt;strong&gt;AOP&lt;/strong&gt;. Создадим абстрактный &lt;strong&gt;Handler&lt;/strong&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public abstract class AbstractHandler implements InvocationHandler {

    private Object targetObject;

    public void setTargetObject(Object targetObject) {
        this.targetObject = targetObject;
    }

    public Object getTargetObject() {
        return targetObject;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Создадим &lt;strong&gt;ProxyFactory&lt;/strong&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class ProxyFactory {

public static Object getProxy(Object targetObject,
        List&amp;lt;AbstractHandler&amp;gt; handlers) {
    Object proxyObject = null;
    if (handlers.size() &amp;gt; 0) {
        proxyObject = targetObject;
        for (int i = 0; i &amp;lt; handlers.size(); i++) {
            handlers.get(i).setTargetObject(proxyObject);
            proxyObject = Proxy.newProxyInstance(targetObject.getClass()
                    .getClassLoader(), targetObject.getClass()
                    .getInterfaces(), handlers.get(i));
        }
        return proxyObject;
    } else {
        return targetObject;
    }
}
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;В AOP существует несколько срезов: &lt;strong&gt;Before&lt;/strong&gt;, &lt;strong&gt;After&lt;/strong&gt;, &lt;strong&gt;AfterThrowing&lt;/strong&gt;, &lt;strong&gt;AfterReturning&lt;/strong&gt; и &lt;strong&gt;Around&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Так как реализации каждого среза могут быть разными, для разных случаев, создадим для них абстрактные классы:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Пример для &lt;strong&gt;AfterHandler&lt;/strong&gt; и &lt;strong&gt;BeforeHandler&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public abstract class AfterHandler extends AbstractHandler {

    /**
     * Handles after the execution of method.
     *
     * @param proxy the proxy
     * @param method the method
     * @param args the args
     */
    public abstract void handleAfter(Object proxy, Method method, Object[] args);

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        Object result = method.invoke(getTargetObject(), args);
        handleAfter(proxy, method, args);
        return result;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;AbstractBeforeHandler:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public abstract class BeforeHandler extends AbstractHandler {

    /**
     * Handles before execution of actual method.
     *
     * @param proxy the proxy
     * @param method the method
     * @param args the args
     */
    public abstract void handleBefore(Object proxy, Method method, Object[] args);

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        handleBefore(proxy, method, args);
        return method.invoke(getTargetObject(), args);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Теперь нам нужно сделать конкретные реализации для каждого из срезов:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class AfterHandlerImpl extends AfterHandler {

    @Override
    public void handleAfter(Object proxy, Method method, Object[] args) {
        //Provide your own cross cutting concern
        System.out.println(method.getName() + Arrays.toString(args));
        System.out.println(&quot;Handling after actual method execution ........&quot;);
    }
}

public class BeforeHandlerImpl extends BeforeHandler {

    @Override
    public void handleBefore(Object proxy, Method method, Object[] args) {
        //Provide your own cross cutting concern
        System.out.println(&quot;Handling before actual method execution ........&quot;);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Теперь мы можем легко проксировать наш &lt;strong&gt;Calculator&lt;/strong&gt; класс:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class TestAopInJDK {

    public static void main(String[] args) {
        CalculatorImpl calcImpl = new CalculatorImpl();
        BeforeHandler before = new BeforeHandlerImpl();
        AfterHandler after = new AfterHandlerImpl();
        List&amp;lt;AbstractHandler&amp;gt; handlers = new ArrayList&amp;lt;AbstractHandler&amp;gt;();
        handlers.add(before);
        handlers.add(after);
        Calculator proxy = (Calculator) ProxyFactory.getProxy(calcImpl,
                handlers);
        int result = proxy.calculate(20, 10);
        System.out.println(&quot;FInal Result :::&quot; + result);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;После запуска вывод в консоль оказывается таким:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;Handling before actual method execution ........
**********Actual Method Execution**********
calculate[20, 10]
Handling after actual method execution ........
Final Result :::2&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Как вы можете заметить срабатывает Before, затем идет работа метода и затем срабатывает After.
&lt;strong&gt;P.S.&lt;/strong&gt;
Многие кто не сильно в теме могут сказать, что такое же можно было реализовать просто написав перед вызовом и после вызова sysout. Да, можно было, но AOP предназначено немного для других целей.Я уже описывал то как мы используем логер для действий вебдрайвера здесь. В своих фреймворках, я дополнительно логирую имена методов и параметры которые он принимают используя AOP. Это позволяет хранить весь код логирования в одном месте,а не розмазывать его по всем классам.&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>А как вы логируете?</title>
      <link>localhost/a-kak-vy-loghiruietie/index.html</link>
      <pubDate>Sat, 28 Mar 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">a-kak-vy-loghiruietie/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Данной статьей хотелось бы поделиться тем, как я переизобрел велосипед и перестал писать логер после каждой строки кода.
Итак, начну с предыстории. Есть у меня проект который организован на основе &lt;strong&gt;Spring + Jbehave + Selenium&lt;/strong&gt;, все вроде как хорошо, тесты бегают, тесты падают. Но вот бывает такое, что тест идет и в одном методе выполняется пару действий - понять какое именно действие вызывает фейл, бывает очень сложно. Что в таком случае делать? Правильно - начинать логировать. А как логировать? Очень просто берем &lt;strong&gt;Slf4j&lt;/strong&gt; делаем:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class SomePage {
    private static final Logger LOG = LoggerManager.getLoggger(SomePage.class);

    public void someMethod(){
        LOG.info(&quot;something happens&quot;);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Как любит говорить один мой знакомый: &quot;казалось бы&quot;. Но здесь всего один метод. При увеличении строк кода, логер будет пропорционально захламлять код. В дополнение не всегда хочеться писать вот эту вот строку в каждом классе:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;private static final Logger LOG = LoggerManager.getLoggger(SomePage.class);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Да, можно использовать &lt;strong&gt;Lombook&lt;/strong&gt;, но не все положительно относятся к библиотекам такого рода.
Передем к более насущной проблеме, скажем есть у вас метод:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public void login(User user){
    driver.find(By.id(&quot;login&quot;)).sendKeys(user.name);
    driver.find(By.id(&quot;pass&quot;)).sendKeys(user.pass);
    driver.find(By.id(&quot;login_btn&quot;)).click();
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Как здесь залогировать то, что я заполнил два поля и тыцнул на кнопку? Первое что приходит на ум - просто добавить логер. А куда добавлять? Перед действием или после? А если я хочу и там и там? Давайте посмотрим:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public void login(User user){
    LOG.info(&quot;Type login {}&quot;,user.name);
    driver.find(By.id(&quot;login&quot;)).sendKeys(user.name);
    LOG.info(&quot;Type password {}&quot;,user.pass);
    driver.find(By.id(&quot;pass&quot;)).sendKeys(user.pass);
    LOG.info(&quot;Click login btn);
    driver.find(By.id(&quot;login_btn&quot;)).click();
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Последний кусок кода выглядит просто ужасно. В таких ситуациях очень кстати приходиться &lt;strong&gt;Selenium WebDriver Event Listener Interface&lt;/strong&gt;. Этот интерфейс предоставляет доступ ко всем основным действиям драйвера:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class EventHandler implements WebDriverEventListener{

    public void afterChangeValueOf(WebElement arg0, WebDriver arg1) {
    // TODO Auto-generated method stub
    }

    public void afterClickOn(WebElement arg0, WebDriver arg1) {
    // TODO Auto-generated method stub
    }

    public void afterFindBy(By arg0, WebElement arg1, WebDriver arg2) {
    // TODO Auto-generated method stub
    }

    public void afterNavigateBack(WebDriver arg0) {
    // TODO Auto-generated method stub
    }
    ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Все что нужно сделать, просто реализовать методы, затем зарегистрировать ваш листенер и начать наслаждаться происходящим:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import org.openqa.selenium.By;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.support.events.EventFiringWebDriver;

public class Main {

    public static void main(String[] args) {

        FirefoxDriver driver = new FirefoxDriver();
        EventFiringWebDriver eventDriver = new EventFiringWebDriver(driver);

        EventHandler handler = new EventHandler();
        eventDriver.register(handler);
        eventDriver.get(&quot;http://www.toolsqa.com/automation-practice-switch-windows/&quot;);
        WebElement element = eventDriver.findElement(By.id(&quot;target&quot;));
        element.click();

    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Используя такой подход можно легко и просто залогировать все действия драйвера.&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>BDD In Test Automation lecture</title>
      <link>localhost/bdd-in-test-automation-lecture/index.html</link>
      <pubDate>Sat, 21 Mar 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">bdd-in-test-automation-lecture/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Моя лекция, которую я проводил в компании, для студентов. В лекции попытался доступным языком рассказать о том, что такое BDD и как его имплеменитровать в жизнь. Сделал небольше овервью таких иснтрументов как &lt;strong&gt;Cucumber&lt;/strong&gt;, &lt;strong&gt;JBehave&lt;/strong&gt;, &lt;strong&gt;Spock&lt;/strong&gt;, &lt;strong&gt;Lettuce&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;videoblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;iframe src=&quot;https://www.youtube.com/embed/9_Ij3ux7l0Y?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;videoblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;iframe src=&quot;https://www.youtube.com/embed/tL9Yavmv0nM?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;videoblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;iframe src=&quot;https://www.youtube.com/embed/PtGkytbbS2o?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;videoblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;iframe src=&quot;https://www.youtube.com/embed/GJFvMQ_IW1Y?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Lettuce Python</title>
      <link>localhost/lettuce-python/index.html</link>
      <pubDate>Sat, 21 Mar 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">lettuce-python/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Готовился я как-то к презентации по Behaviour Driven Development, готовил практические примеры по различным тулам и решил показать пример того как можно реализовать BDD с помощью Python. Посмотрел на Behave и на Lettuce см тут. Мой выбор пал на второй инструмент, не знаю почему, видимо потому что тесты писать проще и быстрее. Дабы не быть голословным приведу пример. Начнем с установки. Ставим Python &lt;strong&gt;2.7 (Это ВАЖНО - на Python 3 работать не будет)&lt;/strong&gt;. Ставим lettuce и selenium:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;pip install lettuce
pip install selenium
pip install PyHumcrest&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Создадим иерархию папок:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;lettuce_demo
    | features&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;В корневом каталоге создадим файлик &lt;strong&gt;terrain.py&lt;/strong&gt;, он будет содержать команды, которые будут выполнять на разных стадиях исполнения тестов, в данном случае файл имеет такое содержание:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from lettuce import before, after, world
from selenium import webdriver
from mapping import site_mapping


@before.each_feature
def setup(server):
    world.browser = webdriver.Firefox()
    world.mapping = site_mapping


@after.all
def tear_down(total):
    world.browser.close()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Затем, в корне,создаем файл &lt;strong&gt;mapping.py&lt;/strong&gt;. Этой файл содержит локаторы элементов, такой себе &lt;strong&gt;PageObject&lt;/strong&gt;, только необычный:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;host_url = &quot;http://pn.com.ua&quot;

site_mapping = {
    &quot;pc_search&quot;: {
        &quot;url&quot;: host_url,
        &quot;computers&quot;: &quot;.//*[@id=&apos;page-content-wrap&apos;]/div/div[1]/div/h1[1]/a&quot;,
        &quot;notebook&quot;: &quot;.//*[@id=&apos;page-content-wrap&apos;]/div[3]/div[1]/div/div[2]/a&quot;,
        &quot;model_number&quot;: &quot;.//*[@id=&apos;page-content-wrap&apos;]/div[3]/div[1]/div[1]/div/div[2]/div[1]/b&quot;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;В локаторых можно использовать как &lt;strong&gt;XPath&lt;/strong&gt; так и СSS Selectors.
В папке features создаем &lt;strong&gt;pc.feature&lt;/strong&gt; - этот файл содержит описание теста.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;Feature: search
  Scenario: Search pc
    Open &quot;pc_search&quot; page
    Click &quot;computers&quot;
    Click &quot;notebook&quot;
    See &quot;2703&quot; in &quot;model_number&quot;

  Scenario: Search pc fail
    Open &quot;pc_search&quot; page
    Click &quot;computers&quot;
    Click &quot;notebook&quot;
    See &quot;27012&quot; in &quot;model_number&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;В создаем &lt;strong&gt;features/steps.py&lt;/strong&gt; - файл содержит описания шагов, используемых в &lt;strong&gt;*.feature&lt;/strong&gt; файлах&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from lettuce import step, world
from hamcrest import *

@step(r&apos;Open &quot;(.*)&quot; page&apos;)
def should_open_main_page(step, page):
    world.current_page = world.mapping[page]
    world.browser.get(world.current_page[&apos;url&apos;])

@step(u&apos;Click &quot;([^&quot;]*)&quot;&apos;)
def click_group1(step, element):
    el = world.browser.find_element_by_xpath(world.current_page[element])
    el.click()

@step(u&apos;See &quot;([^&quot;]*)&quot; in &quot;([^&quot;]*)&quot;&apos;)
def see_group1_in_group2(step, text, element):
    el = world.browser.find_element_by_xpath(world.current_page[element])
    assert_that(el.text, equal_to(text))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Вот и все. В консоли в корне проекта пишем: &lt;strong&gt;lettuce&lt;/strong&gt; - вуаля видим как запускается браузер и проходят тесты.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Вывод:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Lettuce могут использовать как тестировщики так и разработчики.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Высокая устойчивость к изменениям в верстке и структуре сайта в целом благодоря mapping.py&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Выведите ваши тесты на новый уровень!</title>
      <link>localhost/vyvieditie-vashi-tiesty-na-novyi-urovien/index.html</link>
      <pubDate>Fri, 20 Mar 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">vyvieditie-vashi-tiesty-na-novyi-urovien/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Пару месяцев назад, я задумался - вот есть у меня пару сотен тестов, фреймворк там да, все как положенно! Тесты бегают 24\7 с 98% пасс результатом, отчет собирается и успешно уходит всем манагерам. Казалось бы - жизнь удалась. Но, за всем прекрасным всегда скрывается, что то ужасное. Решил я попробовать прогнать проект через &lt;strong&gt;Sonar&lt;/strong&gt;. Собственно таким введением я хотел начать рассказ о том стоит ли применять статические анализаторы кода для фреймворка и тестов. Статический анализатор предназначен для того, чтобы следить за чистотой кода и отслеживать ошибки типа переполнение буфера или возможный &lt;em&gt;NullPointerException&lt;/em&gt;. Устанавливается сонар очень просто: скачиваем архив, распаковываем, ставим &lt;strong&gt;MySQL&lt;/strong&gt;, прописываем в пропертях сонара путь к базе, стартуем батник и все. Несколько простых шагов и у нас есть сервер. Далее нам нужно просканировать проект. Если проект на &lt;strong&gt;Maven&lt;/strong&gt;, то просто в pom нужно вписать:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&amp;lt;project&amp;gt;
  ...
  &amp;lt;build&amp;gt;
    &amp;lt;!-- To define the plugin version in your parent POM --&amp;gt;
    &amp;lt;pluginManagement&amp;gt;
      &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;sonar-maven-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;2.5&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        ...
      &amp;lt;/plugins&amp;gt;
    &amp;lt;/pluginManagement&amp;gt;
    &amp;lt;!-- To use the plugin goals in your POM or parent POM --&amp;gt;
    &amp;lt;plugins&amp;gt;
      &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;sonar-maven-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.5&amp;lt;/version&amp;gt;
      &amp;lt;/plugin&amp;gt;
      ...
    &amp;lt;/plugins&amp;gt;
  &amp;lt;/build&amp;gt;
  ...
&amp;lt;/project&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Далее в Maven setting.xml добавляем:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&amp;lt;profile&amp;gt;
    &amp;lt;id&amp;gt;sonar&amp;lt;/id&amp;gt;
    &amp;lt;activation&amp;gt;
       &amp;lt;activeByDefault&amp;gt;true&amp;lt;/activeByDefault&amp;gt;
    &amp;lt;/activation&amp;gt;
&amp;lt;properties&amp;gt;
&amp;lt;sonar.jdbc.url&amp;gt;jdbc:postgresql://localhost/sonar&amp;lt;;/sonar.jdbc.url&amp;gt;
&amp;lt;sonar.jdbc.driver&amp;gt;org.postgresql.Driver&amp;lt;/sonar.jdbc.driver&amp;gt;
&amp;lt;sonar.jdbc.username&amp;gt;user&amp;lt;/sonar.jdbc.username&amp;gt;
&amp;lt;sonar.jdbc.password&amp;gt;password&amp;lt;/sonar.jdbc.password&amp;gt;
&amp;lt;!-- SERVER ON A REMOTE HOST --&amp;gt;
&amp;lt;sonar.host.url&amp;gt;http://localhost:9000&amp;lt;/sonar.host.url&amp;gt;
   &amp;lt;/properties&amp;gt;
&amp;lt;/profile&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Вот и все! При запущенном сервере - выполняем &lt;strong&gt;mvn sonar:sonar&lt;/strong&gt; ждем завершения сканирования. Далее отрываем в браузере адрес, который мы прописывали:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&amp;lt;sonar.host.url&amp;gt;http://localhost:9000&amp;lt;/sonar.host.url&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Проделав все эти действия, я был шокирован. В проекте был ужжаасный код. Сделав выводы, на новом проете, я начал применять Sonar с самого первого дня. Спустя три месяца, мы создали 300 тестов. Техникал дебт равен 0.1. А сложность кода - 1.2. Вы можете себе представить такое? Разработчики даже подшучивают иногда, что тесты &quot;чище&quot; чем сам проект. Вот так вот Sonar помог повыситься качество кода тестов. А вы используете статические анализаторы кода?&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>WebDriver factory без IF-ELSE</title>
      <link>localhost/webdriver-factory-biez-if-else/index.html</link>
      <pubDate>Sat, 7 Mar 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">webdriver-factory-biez-if-else/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;В этой заметке покажу, как можно написать WebDriver factory без применения IF-ELSE.
Зачастую во фреймворках в случае кросс-браузерного тестирования приходится писать драйвер фэктори. Большинство реализаций, которые мне приходилось видеть, выглядели так:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;BrowserFactory.class&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;class BrowserFactory{
    public static final WebDriver DEFAULT_FF = new FirefoxDriver();

 public static WebDriver getDriver(String name){
     WebDriver driver = null;
     if(&quot;FIREFOX&quot;.equalsIgnoreCase(name)){
        driver= new FirefoxDriver();
     }else if(&quot;CHROME&quot;.equalsIgnoreCase(name)){
         driver = new ChromeDriver();
     }else if(&quot;IE&quot;.equalsIgnoreCase(name)){
         driver = new InternetExplorerDriver();
     }else {
         driver = DEFAULT_FF;
     }
     return driver;
 }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Но такая реализация, скажем так, не самая хорошая: читабельность кода страдает, человеку приходится гадать, как же правильно задать имя браузера, ну и самое неприятное - куча if-else. Давайте посмотрим, как можно улучшить ситуацию.
Объектно-ориентированные языки программирования обладают мощнейщим принципом - полиморфизмом. Его мы и будем использовать, чтобы удалить if-else в коде. В результате читабельность кода значительно повысится.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Рефлексия&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Первое &quot;топорное&quot; решение (я назвал бы его &quot;решением для реальных пацанов&quot;):&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class Browsers{
    public static WebDriver newBrowser(String name){
        return Class.forName(name).newInstance();
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Смотрится очень просто, НО сложность заключается в том, что человек должен помнить полное имя класса. К тому же, использование рефлексии повышает степень брутальности в пару раз. Поэтому таких решений следует избегать.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Второе решение более приемлемое - использование Map.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class Browsers{
    private static Map&amp;lt;String,WebDriver&amp;gt; drivers = new HashMap&amp;lt;&amp;gt;(){
        put(&quot;CHROME&quot;,new ChromeDriver());
        put(&quot;FIREFOX&quot;,new FirefoxDriver());
        put(&quot;IE&quot;,new InternetExplorerDriver());
    }

    public static WebDriver newDriver(String name){
        return drivers.get(name);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Это решение обладает недостатком: нужно знать правильное имя драйвера, которое задано в Map.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Switch&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;switch (name) {
    case &quot;FIREFOX&quot;: return new FirefoxDriver();
    case &quot;CHROME&quot;: return new ChromeDriver();
    case &quot;IE&quot;: return new InternetExplorerDriver();
    default: return DEFAULT_FF;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Enum&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Самое элегантное решение:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public enum Browsers {
    CHROME {
        public WebDriver create(){
            return new ChromeDriver();
        }
    },
    IE {
        public WebDriver create(){
            return new InternetExplorerDriver();
        }
    },
    FIREFOX {
        public WebDriver create() {
            return new FirefoxDriver();
        }
    };

    public WebDriver create(){
        return null;
    }
}

class Test {
    public static void main(String[] args) {
       WebDriver driver = Browsers.FIREFOX.create();
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Классно, не правда ли? Нету надоедливых if-else, нету строк, которые нужно помнить - просто вызываем нужный нам тип драйвера и все. Лично я предпочитаю этот метод.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;P.S. Конструкция if-else делает код сложным для чтения, поэтому нужно стараться избегать их использования.&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Замечательный каталог рефакторинга</title>
      <link>localhost/zamiechatielnyi-katalogh-riefaktoringha/index.html</link>
      <pubDate>Sun, 1 Mar 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">zamiechatielnyi-katalogh-riefaktoringha/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Совсем недавно решил окунуться в мир &quot;правильного&quot; рефакторинга. Зачастую так бывает: люди думают, что они умеют рефакторить правильно. Изменил пару строк, переименовал пару переменных - зарефакторил. Порешал как царь =). Но на самом деле по сравнению с настоящим рефакторингом - это всего лишь махание руками и трата драгоценного времени. Чтобы научиться рефакторить и узнать, зачем это делать, можно почитать книгу Фаулера - &quot;Рефакторинг - улучшение существующего кода&quot;. А еще можно зайти на этот замечательный ресурс, в котором описаны основные проблемы - &quot;запахи кода&quot;, а также советы по их устранению и улучшению существующего кода.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;http://refactoring.guru/ru/&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Удачного рефакторинга!&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Gradle run single TestNG method</title>
      <link>localhost/gradle-run-single-test-method/index.html</link>
      <pubDate>Fri, 27 Feb 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">gradle-run-single-test-method/index.html</guid>
      	<description>
	&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;http://kaczanowscy.pl/tomek/sites/default/files/2012_04_uncle_sam_170.png&quot; alt=&quot;2012 04 uncle sam 170&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is the shortest remark ever. Just a few word and a few lines of code. So to run single test with &lt;strong&gt;Gradle&lt;/strong&gt; and &lt;strong&gt;TestNG&lt;/strong&gt; you can use one of this approaches:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Run someSpecificFeature method from &lt;strong&gt;SomeTest&lt;/strong&gt; in specific &lt;strong&gt;arg.gradle&lt;/strong&gt; package:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;gradle test --tests org.gradle.SomeTest.someSpecificFeature&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Run &lt;strong&gt;someSpecificFeature&lt;/strong&gt; method from &lt;strong&gt;SomeTest&lt;/strong&gt; in any package:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;gradle test --tests *SomeTest.someSpecificFeature&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Run all methods in SomeSpecificTest class:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;gradle test --tests *SomeSpecificTest&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Run all in specific package:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;gradle test --tests all.in.specific.package*&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Run all in classes which name starts with IntegTest:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;gradle test --tests *IntegTest

gradle test --tests *IntegTest*ui*&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Run &lt;strong&gt;someTestTask&lt;/strong&gt; from any &lt;strong&gt;UiTest&lt;/strong&gt; and &lt;strong&gt;someTestTask&lt;/strong&gt; from any &lt;strong&gt;WebTest*ui&lt;/strong&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;gradle someTestTask --tests *UiTest someOtherTestTask --tests *WebTest*ui&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Cheers! Thats all;)&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Мощь Groovy: Reading URL Content</title>
      <link>localhost/groovy-power-reading-url-content/index.html</link>
      <pubDate>Thu, 26 Feb 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">groovy-power-reading-url-content/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Groovy adds some methods to the URL class which make reading data from an URL easy. For example the text property returns the complete contents of the document that is identified by the URL. Or we can use the &lt;strong&gt;eachLine()&lt;/strong&gt; method to loop through each line of the document. Groovy also adds a &lt;strong&gt;toURL()&lt;/strong&gt; to the String class to make a URL object.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def url = &quot;http://www.mrhaki.com/url.html&quot;.toURL()

assert &apos;&apos;&apos;\
     Simple test document
     for testing URL extensions
     in Groovy.
&apos;&apos;&apos; == url.text

def result = []
    url.eachLine {
        if (it =~ /Groovy/) {
        result &amp;lt;&amp;lt; it
    }
}
assert [&apos;in Groovy.&apos;] == result

url.withReader { reader -&amp;gt;
    assert &apos;Simple test document&apos; == reader.readLine()
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;That&amp;#8217;s all, just simple.&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>&quot;Правильный&quot; тестовый фреймворк</title>
      <link>localhost/pravilnyi-tiestovyi-frieimvork/index.html</link>
      <pubDate>Sun, 22 Feb 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">pravilnyi-tiestovyi-frieimvork/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Несколько мыслей о том, каким должен быть &quot;правильный&quot; тестовый фреймворк.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;http://www.ymag.it/wp-content/uploads/2014/11/robot_in_movimento.jpg&quot; alt=&quot;robot in movimento&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;По моему мнению, степень правильности определяется исходя из требований и задач, которые должен будет выполнять фреймворк. К примеру, если на проекте есть и веб-сервисы и UI часть, то при написании фреймворка для UI тестирования следовало бы изначально закладывать возможность создавать предусловия для тестов используя веб-серввисы. Если же возможности такой нету, то просто делайте архитектуру для UI тестирования.
Чаще всего начинающие автоматизаторы совершают большую ошибку - делаем, как получается, а потом будем рефакторить. Зачастую это самое &quot;потом&quot; не наступает. Но все же давайте мыслить структурировано: фреймворк должен быть модульным. Если вы пишите фреймворк на объектно-ориентированном языке ( &lt;strong&gt;Java,C#,Python&lt;/strong&gt; ), то вы обязаны выделять функциональности и &quot;отделять мух от котлет&quot;. В противном случае будет &quot;макаронный код&quot;, а к нему в придачу большие затраты на поддержку тестов и всей инфраструктуры. Модульный фреймворк можно сравнить с конструктором лего.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;http://www.euromag.ru/storage/c/2010/09/15/1284538112,397574_86.jpg&quot; alt=&quot;1284538112,397574 86&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Когда есть такие маленкие блоки, как &lt;strong&gt;PageObject&lt;/strong&gt;, &lt;strong&gt;DataProvider&lt;/strong&gt;,&lt;strong&gt;DAO&lt;/strong&gt;, &lt;strong&gt;BaseTest&lt;/strong&gt; class, собрать из этого всего фреймворк может даже джуниор, который пришел к вам на проект пару недель назад. Еще одно преимущество модульности в том, что вы легко можете заменить один элемент на другой, поменяв реализацию либо инструмент. Модульность дает вам гораздо больший радиус поворота. Скажем, когда у вас на проекте 15 - 20 тестовых сценариев, то вы можете не задумываясь в них ковыряться и тратить по 15-20 минут в день на поддержку, а вот когда их становится 1500-2000, то тут начинаются пляски с бубном, сопли и визги: &quot;какой же хреновый у нас фреймворк, че ж мы раньше-то не делали хорошо, сейчас уже поздно&amp;#8230;&amp;#8203;&quot; Так вот, чтобы избежать такой ситуации, мой вам совет перед началом разработки фреймворка: подумайте, выделите основные части, запрограммируйте их в виде модулей, напишите пару тестов на конкретные функциональности, поэкспериментируйте, найдите свой рецепт успеха. Лично мой опыт показывает, что модульный фреймворк выигрывает у &quot;макаронного кода&quot; по всем параметрам.&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Небольшой видосик про Jenkins</title>
      <link>localhost/niebolshoi-vidosik-pro-jenkins/index.html</link>
      <pubDate>Sat, 14 Feb 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">niebolshoi-vidosik-pro-jenkins/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Решил поделиться одним из первых своих выступлений! Enjoy;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;videoblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;iframe src=&quot;https://www.youtube.com/embed/tXFENp-RFWs?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Java Simple REST Client</title>
      <link>localhost/java-rest-client/index.html</link>
      <pubDate>Sat, 7 Feb 2015 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">java-rest-client/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Привет! Новая статейка о том, как можно сваять клиент на Java для работы с REST API.
Я покажу два способа, как можно добиться желаемого результата быстро и качественно. Оба способа предусматривают использование сторонних библиотек.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Способ первый - Apache HTTPClient&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Библиотека &lt;code&gt;Apache HttpClient&lt;/code&gt; значительно упрощает обработку HTTP запросов. Для того, чтобы ею воспользоваться, можно пойти на сайт Apache и там почитать, поковыряться, но я использую &lt;code&gt;Maven&lt;/code&gt; - поэтому у меня просто дэпэнденси:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.httpcomponents&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;httpclient&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.3.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ниже показаны примеры запросов GET:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.DefaultHttpClient;
public class Test {
    public static void main(String[] args) throws ClientProtocolException,IOException {
        HttpClient client = new DefaultHttpClient();
        HttpGet request = new HttpGet(&quot;http://restUrl&quot;);
        HttpResponse response = client.execute(request);
        BufferedReader rd = new BufferedReader (new InputStreamReader(response.getEntity().getContent()));
        String line = &quot;&quot;;
        while ((line = rd.readLine()) != null) {
          System.out.println(line);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;POST:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.DefaultHttpClient;
public class Test {
    public static void main(String[] args) throws ClientProtocolException, IOException {
        HttpClient client = new DefaultHttpClient();
        HttpPost post = new HttpPost(&quot;http://restUrl&quot;);
        StringEntity input = new StringEntity(&quot;product&quot;);
        post.setEntity(input);
        HttpResponse response = client.execute(post);
        BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));
        String line = &quot;&quot;;
        while ((line = rd.readLine()) != null) {
            System.out.println(line);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Существует возможность отправлять несколько параметрос с помощью POST:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.message.BasicNameValuePair;
public class Test {
    public static void main(String[] args) throws ClientProtocolException, IOException {
        HttpClient client = new DefaultHttpClient();
        HttpPost post = new HttpPost(&quot;http://restUrl&quot;);
        List nameValuePairs = new ArrayList(1);
        nameValuePairs.add(new BasicNameValuePair(&quot;name&quot;, &quot;value&quot;)); //you can as many name value pair as you want in the list.
        post.setEntity(new UrlEncodedFormEntity(nameValuePairs));
        HttpResponse response = client.execute(post);
        BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));
        String line = &quot;&quot;;
        while ((line = rd.readLine()) != null) {
            System.out.println(line);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Способ второй - Jersey&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Jersey - это имплементация для &lt;strong&gt;JSR-311&lt;/strong&gt; в &lt;strong&gt;Java&lt;/strong&gt;. Jersey содержит в себе REST сервер и REST client.
Пример GET запроса:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import java.io.IOException;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.UriBuilder;
import org.apache.http.client.ClientProtocolException;
import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.WebResource;
import com.sun.jersey.api.client.config.ClientConfig;
import com.sun.jersey.api.client.config.DefaultClientConfig;
public class Test {
    public static void main(String[] args) throws ClientProtocolException, IOException {
        ClientConfig config = new DefaultClientConfig();
        Client client = Client.create(config);
        WebResource service = client.resource(UriBuilder.fromUri(&quot;http://restUrl&quot;).build());
        // getting XML data
        System.out.println(service. path(&quot;restPath&quot;).path(&quot;resourcePath&quot;).accept(MediaType.APPLICATION_JSON).get(String.class));
        // getting JSON data
        System.out.println(service. path(&quot;restPath&quot;).path(&quot;resourcePath&quot;).accept(MediaType.APPLICATION_XML).get(String.class));
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;POST запрос c несколькими параметрами:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import java.io.IOException;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.core.UriBuilder;
import org.apache.http.client.ClientProtocolException;
import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.WebResource;
import com.sun.jersey.api.client.config.ClientConfig;
import com.sun.jersey.api.client.config.DefaultClientConfig;
import com.sun.jersey.core.util.MultivaluedMapImpl;
public class Test {
    public static void main(String[] args) throws ClientProtocolException, IOException {
        ClientConfig config = new DefaultClientConfig();
        Client client = Client.create(config);
        WebResource webResource = client.resource(UriBuilder.fromUri(&quot;http://restUrl&quot;).build());
        MultivaluedMap formData = new MultivaluedMapImpl();
        formData.add(&quot;name1&quot;, &quot;val1&quot;);
        formData.add(&quot;name2&quot;, &quot;val2&quot;);
        ClientResponse response = webResource.type(MediaType.APPLICATION_FORM_URLENCODED_TYPE).post(ClientResponse.class, formData);
        System.out.println(&quot;Response &quot; + response.getEntity(String.class));
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Существует возможность использовать свой собственный класс для POST:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;ClientResponse response = webResource.path(&quot;restPath&quot;).path(&quot;resourcePath&quot;).
type(MediaType.APPLICATION_JSON).accept(MediaType.APPLICATION_JSON).post(ClientResponse.class, myPojo);
System.out.println(&quot;Response &quot; + response.getEntity(String.class));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Как вы можете заметить, обе представленные здесь библиотеки позволяют достаточно легко создать запросы и получить ответы от сервера, обработать их и вывести результат. Лично мне больше нравится Jersey - просто из-за того, что он не такой брутальный, как Apache, но выбирать Вам =)&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Что такое Flaky тест?</title>
      <link>localhost/chto-takoie-flacky-tiest/index.html</link>
      <pubDate>Tue, 2 Dec 2014 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">chto-takoie-flacky-tiest/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;image::http://cdn.meme.am/instances/500x/52587305.jpg&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Если у вас нету &lt;strong&gt;Flacky&lt;/strong&gt; тестов - значит вы занимаетесь чем-то нереальным :). &lt;strong&gt;Flacky&lt;/strong&gt; тесты - это зло! Это то, с чем приходится бороться днями, а бывает - и неделями.
Жизненный пример: написали вы свой &lt;strong&gt;Selenium&lt;/strong&gt; тест, прогнали его, отладили, закомитили - все прекрасно! Приходите на следующий день, ну или через пару-тройку дней, смотрите: он зеленый. &quot;Ну прекрасно&quot;, - думаете, смотрите еще через время - он упал (по никому не понятной причине), ведь код не менялся и приложение работает нормально. Перезапускаете тест - он проходит, все хорошо. Видимо, планеты в небе так встали, и он свалился :). Спустя несколько билдов вы замечаете, что этот тест ведет себя, как лампочка на новогодней елке - мигает: &lt;strong&gt;FAIL, PASS,FAIL,PASS&lt;/strong&gt;&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Как с этим бороться? Ответ как всегда очень прост - нужно разбираться. Как говорится, у любой проблемы есть имя, фамилия и отчество. Большинство Flaky тестов случается из-за банальной невнимательности. Некоторые из них найти легко, над некоторыми же нужно пораскинуть мозгами. Приведу пример: был у меня тест, который должен был открыть модальный диалог и в нем продолжить работу.
Задача достаточно простая, решается за 5 (нет, 10 минут) :). Я написал метод:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;private void switchToRiskFactorDialog(String title) {
            String targetWindow = waitForWindowTitle(title);
            switchTo().window(targetWindow);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Все просто: метод ждал, пока появится окно с нужным title и затем делал switch в новое окно. Все работало прекрасно, пока я не заметил, что у меня тест два раза проходит, а один раз валится с &lt;em&gt;NullPointerException&lt;/em&gt;. Оказалось, что подставил меня метод waitForWindowTitle. Один раз он дожидался, пока окно появится, а в другой принимал решение, что окно появилось, хотя на самом деле его еще не было. Вот и все, таким образом я избавился от &lt;strong&gt;Flaky&lt;/strong&gt; теста.&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>О TestNG, Excel и DataProvider</title>
      <link>localhost/smart-excel-reader-for-testng-dataprovided/index.html</link>
      <pubDate>Thu, 27 Nov 2014 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">smart-excel-reader-for-testng-dataprovided/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Сегодня пост о том, как справиться с чтением Excel файлов, а именно - написать &quot;умный DataReader&quot;.
Excel файлы удобно использовать для храннения тестовых данных в тестовых фреймворках, что позволяет вынести данные из тестов. Так сказать: &lt;strong&gt;&quot;Долой хардкод!&quot;&lt;/strong&gt;.
Такой подход называют D&lt;strong&gt;ata-Driven Testing&lt;/strong&gt;. Это очень удобно, потому что любой человек (даже не технарь) может изменить данные требуемые для теста: вам не нужно лезть в код и что-то там менять. В качестве тестового фреймворка будем использовать &lt;strong&gt;TestNG&lt;/strong&gt;, потому что у него есть много преимуществ, среди которых - DataProvider. Для чтения Excel файлов я использую библиотеку - &lt;strong&gt;Apache POI&lt;/strong&gt;.
Задача состоит в том, чтобы написать ридер, который будет находить строку, соответствующую имени тестового метода, извлекать данные и передавать в тест. Итак, начнем по порядку: создаем класс &lt;strong&gt;ExcelReader&lt;/strong&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;ExcelReader.class&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class ExcelReader {

private XSSFSheet excelWSheet;
private XSSFWorkbook excelWBook;
private XSSFCell cell;

// This method is to set the File path and to open the Excel file
public void setExcelFile(String Path, String SheetName) {
    try {
        // Open the Excel file
        FileInputStream ExcelFile = new FileInputStream(Path);
        // Access the required test data sheet
        excelWBook = new XSSFWorkbook(ExcelFile);
        excelWSheet = excelWBook.getSheet(SheetName);
    } catch (Exception e) {
        System.out.println(&quot;Exception &quot; + e.getMessage());
    }
}
    // Add all below described methods here
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Теперь начинается самое интересное! Нам нужен метод, который будет в столбце искать строку с нужным нам именем.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public List getRowContains(String testCaseName, int colNum){
     List list = new ArrayList&amp;lt;&amp;lt;&amp;gt;&amp;gt;();
     int rowCount = getRowUsed();
     for (int i = 0; i &amp;lt;&amp;lt;= rowCount; i++) {
        String cellData = getCellData(i, colNum);
        if (cellData.equalsIgnoreCase(testCaseName)) {
                    list.add(i);
            }
        }
        return list;
}

public int getRowUsed(){
   return excelWSheet.getLastRowNum();
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Метод возвращает лист с номерами строк на случай, если у нас один тест нужно перезапустить несколько раз с разными данными.
Напишем еще пару вспомогательных методов:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public String getCellData(int rowNum, int colNum) {
    cell = excelWSheet.getRow(rowNum).getCell(colNum);
    return Cell.getStringCellValue();
}

public List[] getRowData(int rowNo) {
        List[] arr = new List[1];
        List list = new ArrayList();
        int startCol = 1;
        int totalCols = excelWSheet.getRow(rowNo)
        .getPhysicalNumberOfCells();
        for (int i = startCol; i &amp;lt; totalCols; i++) {
           String cellData = getCellData(rowNo, i);
           list.add(cellData);
        }
        arr[0] = list;
        return arr;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Здесь следовало бы обратить внимание на метод getRowData, возвращающий массив листов. Звучит немного странно, но таким способом мы можем считывать данные из строк с различным количеством колонок. Ну и наконец последний метод:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public Object[][] getTableArray(List&amp;lt;Integer&amp;gt; rowsNo) {
        Object[][] tabArray = new Object[rowsNo.size()][];
        for (int i = 0; i &amp;lt; rowsNo.size(); i++) {
            tabArray[i] = getRowData(rowsNo.get(i));
        }
        return tabArray;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;По требованию &lt;strong&gt;DataProvider&lt;/strong&gt; должен возвращать двухмерный массив обджектов, что и делает &lt;em&gt;getTableArray&lt;/em&gt;. Теперь мы легко можем создавать в тестовых классах метод и использовать его в качетве источника данных для тестов:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;TestClass.class&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class TestClass{

   @DataProvider
   public Object[][] testData(Method method,String sheet){
        ExcelReader excelReader = new ExcelReader();
        excelReader.setExcelFile(config.getProperty(&quot;TestData.xlsx&quot;), sheet);
        List rowsNo = excelReader.getRowContains(method.getName(), COL_NUM);
        return excelReader.getTableArray(rowsNo);
  }

  @Test(dataProvider = &quot;testData&quot;)
  public void userLogin(List data) {
        data.get(0);
        data.get(1);
        ...
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Вот и вступил в силу наш массив листов: вместо того, чтобы передавать ОГРОМНОЕ количество параметров, мы передаем элегантный список, с которым легко и просто работать. Создаем Excel файл, заполняем данными, запускаем тесты и наслаждаемся, попивая чаек:)&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Как я изобрел свой Jenkins Emailer</title>
      <link>localhost/jenkins-emailer/index.html</link>
      <pubDate>Sat, 22 Nov 2014 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">jenkins-emailer/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Велкам!
Второй пост не задержался. Как и обещал, расскажу о том, как мне удалось, казалось бы, из невозможного сделать возможное (изобрести свой велосипед).
Применив хитрость с &lt;strong&gt;Jenkins API&lt;/strong&gt;, как было показано в предыдущем посте, я не только добыл нужную мне информацию из недр этого чУдного инструмента, но и заставил ее приносить пользу проекту.
Итак, по порядку. Если Jenkins предоставляет возможность получать данные в формате &lt;strong&gt;JSON&lt;/strong&gt; - значит мы можем легко и просто обрабатывать эти данные.
Я буду приводить в пример некоторые куски кода, которые являются ключевыми.
Так вот! Вернемся к нашим баранам. Имея URL к &lt;strong&gt;JSON&lt;/strong&gt; файлу, скачать его можно так (осторожно: &lt;strong&gt;Java&lt;/strong&gt; code detected :)) :&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public static String callURL(URL url) {
        StringBuilder sb = new StringBuilder();
        URLConnection urlConn = null;
        InputStreamReader in = null;
        try {
            urlConn = url.openConnection();
            if (urlConn != null)
                urlConn.setReadTimeout(60 * 1000);
            if (urlConn != null &amp;amp;&amp;amp; urlConn.getInputStream() != null) {
                in = new InputStreamReader(urlConn.getInputStream(),
                        Charset.defaultCharset());
                BufferedReader bufferedReader = new BufferedReader(in);
                if (bufferedReader != null) {
                    int cp;
                    while ((cp = bufferedReader.read()) != -1) {
                        sb.append((char) cp);
                    }
                    bufferedReader.close();
                }
            }
            in.close();
        } catch (Exception e) {
            LOG.error(&quot;Exception while calling URL:&quot;
                    + url.toString());
        }
        return sb.toString();
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Метод принимает адрес (URL), а возвращает непосредственно содержание JSON файла в строковом представлении.
Далее нам нужно дессериализовать &lt;strong&gt;JSON&lt;/strong&gt; в объект &lt;strong&gt;JobObject&lt;/strong&gt;. Это очень просто сделать с помощью библиотеки &lt;strong&gt;Google GSON&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public static Object jsonToObject(String json, Class c) {
        Gson gson = new Gson();
        Object obj = gson.fromJson(json, c);
        return obj;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;В данном случае был создал класс JobObject, в котором я сохранял интересующую меня информацию:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class JobObject {
    private long duration;
    private long estimatedDuration;
    private String fullDisplayName;
    private int number;
    private String result;
    private long timestamp;
    private String url;
    private String builtOn;
    private String RUNNING_STATUS = &quot;RUNNING&quot;;
    private BuildInfo buildInfo;
    private ArrayList actions;
    // Getters  and setters

    public String getStatus() {
        if (result == null) {
            return RUNNING_STATUS;
        }
        return result;
    }

    public boolean finished() {
        return !getStatus().equals(RUNNING_STATUS);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Таким образом, имея набор &lt;strong&gt;JsonObject&lt;/strong&gt;, я написал еще пару классов хелперов и обработчиков, с помощью которых отбирал для себя только те &lt;strong&gt;JobObject&lt;/strong&gt;, которые имели статус &lt;strong&gt;finished&lt;/strong&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public static List getFinishedJobs(List jobs) {
        List finishedJobs = new ArrayList();
        for (JobObject job : jobs) {
            if (job.finished()) {
                finishedJobs.add(job);
            }
        }
        return finishedJobs;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Имея на руках все козыри, я преобразовал (переопределил метод toString) JobObject в тесктовое представление.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;Job 4.9.1.1_Tests #91 is FINISHED.
Job Status - SUCCESS.
Build info: PRE-RELEASE BUILD 12dev.0228.zip
You can find detailed information by the following link:
http://host:port/job/4.9.1.1_Branch_Tests/91/
Failed: 24 Total: 480&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;В итоге: использовав &lt;a href=&quot;http://commons.apache.org/proper/commons-email/&quot;&gt;Apache Commons Email&lt;/a&gt;, я отправляю данные на почтовые ящики, тем самым оповещая всех о результатах наших тестов. Хотите и вам одно сброшу ;)&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Как приручить Jenkins API</title>
      <link>localhost/kak-prruchit-jenkins-api/index.html</link>
      <pubDate>Wed, 19 Nov 2014 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">kak-prruchit-jenkins-api/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Небольшой пост о том, как можно добраться до внутренностей &lt;a href=&quot;https://jenkins.io/index.html&quot;&gt;Jenkins&lt;/a&gt;.
Бывают ситуации, когда СI сервер установлен где-то на удаленной машине, доступ к которой осуществляется через VPN. В общем ситуация сложная, а информацию о джобах и письма от дженкинса получать хотелось бы.
В таком случае в помощь приходит &lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/Remote+access+API&quot;&gt;Jenkins API&lt;/a&gt;.
API позволяет извлекать информацию в трех форматах XML, JSON и Python.
Как это работает? Очень просто: все что нужно - вбить в браузере в строке адреса:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;http://&amp;lt;jenkins host&amp;gt;/api/json&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Вуаля! Круто, не правда ли? Но текст не читабелен. Решается это просто: нужно добавить pretty формат:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;http://9.21.103.66:8255/jenkins/api/json?pretty=true&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Теперь на экране в &lt;strong&gt;JSON&lt;/strong&gt; формате отображается информация обо всех джобах. Для того, чтобы опуститься на уровень одного &lt;strong&gt;Job&lt;/strong&gt;, необходимо просто указать имя:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;http://&amp;lt;JENKINS_HOST&amp;gt;/job/&amp;lt;JOB_NAME&amp;gt;/api/json?pretty=true&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;А чтобы получить информацию о какой-либо сборке, нужно всего лишь указать ее номер:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;http://&amp;lt;JENKINS_HOST&amp;gt;/job/&amp;lt;JOB_NAME&amp;gt;/&amp;lt;BUILD_NUMBER&amp;gt;/api/json?pretty=true&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;После получения информации ее можно использовать в благих целях. Но об этом я расскажу в следующий раз&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Welcome!</title>
      <link>localhost/first-post/index.html</link>
      <pubDate>Sun, 16 Nov 2014 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">first-post/index.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Привет! Случилось: блог для автоматизторов от автоматизатора!&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>

  </channel> 
</rss>
